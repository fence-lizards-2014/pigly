<div class="restaurant_container">
	<h1><%= @restaurant.name %> </h1>

	<div id="tab-container" class="tab-container">
	  <ul class='tab-bar' style="display:none;">
	    <li class='tab'><a href="#menu-tab"></a></li>
	    <li class='tab'><a href="#visualize-tab"></a></li>
	    <li class='tab'><a href="#info-tab"></a></li>
	  </ul>
	  <div id="menu-tab">
	    <h2>Menu</h2>
	    <% @top_five_items.each do |item| %>
			  <%= div_for(item, class: "top_five_items") do %>
			    <div class="item-info" class="item-ellipse"><%= item.name %></div>
			    <div class="votes">
			      <!-- CLEAN THIS SEND LOGIC TO CONTROLER -->
			      <%= link_to '', votes_path(direction: 'up', item_id: item.id), remote: true, method: 'post', id: 'upvote', class: 'ss-like' %>
			      <span class="vote-holder"> <%= item.calculate_percentage %>%</span>
			      <%= link_to '', votes_path(direction: 'down', item_id: item.id), remote: true, method: 'post', id: 'downvote', class: 'ss-dislike'%>
			    </div>
			  <% end %>
			<% end %>
			<a class="show_all_items_btn" href="javascript:unhideItems()"><span class="slicknav_menutxt">MORE</span></a>
			 <% @remaining_items.each do |item| %>
			  <%= div_for(item, class: "remaining_items") do %>
			    <div class="item-info" class="item-ellipse"><%= item.name %></div>
			    <div class="votes">
			      <!-- CLEAN THIS SEND LOGIC TO CONTROLER -->
			      <%= link_to '', votes_path(direction: 'up', item_id: item.id), remote: true, method: 'post', id: 'upvote', class: 'ss-like' %>
			      <span class="vote-holder"> <%= item.calculate_percentage %>%</span>
			      <%= link_to '', votes_path(direction: 'down', item_id: item.id), remote: true, method: 'post', id: 'downvote', class: 'ss-dislike'%>
			    </div>
			  <% end %>
			<% end %>
	  </div>

	  <div id="visualize-tab">
	    <p class="display_text">Gender Distribution</p>
	  	<div class="canvas">
		  	<div class="femaledisplay"></div>
		  	<div class="maledisplay"></div>
		  </div>
	 		<p class="display_text">Item Force Layout</p>
	    <div class="itemdisplay"></div>

	   	<p class="display_text">Patron Age Cluster</p>
      <div class="agedisplay">
        <div class="infobox">
          <p id="data-info"></p>
        </div>
      </div>

	  </div>

	  <div id="info-tab">
	  	<p>Address: <%= @restaurant.address %></p>
	  	<p>Website: <%= @restaurant.website %></p>
	  	<p>Phone Number: <%= @restaurant.phone %></p>
	  	<div id="map-canvas"/>
	  </div>
	</div>

</div>

<script type="text/javascript">
  function initialize() {
  	var myLatlng = new google.maps.LatLng(<%= @restaurant.latitude %>,<%= @restaurant.longitude %>);
    var mapOptions = {
      center: myLatlng,
      zoom: 16,
      panControl: false,
      zoomControl: false,
      streetViewControl: false,
      mapTypeControl: false
    };
    var map = new google.maps.Map(document.getElementById("map-canvas"),
        mapOptions);
    var marker = new google.maps.Marker({
      position: myLatlng,
      map: map,
      title: 'Hello World!'
  });
	}
	google.maps.event.addDomListener(window, 'load', initialize);
</script>

<script type="text/javascript">

// infobox code
// this will be ran whenever we mouse over a circle
var myMouseOverFunction = function() {
  var node = d3.select(this);
  // show infobox div on mouseover.
  // block means sorta "render on the page" whereas none would mean "don't render at all"
  d3.select(".infobox").style("display", "block");
  // add test to p tag in infobox
  d3.select("#data-info")
    .text("Pigglets at the age of " + this.__data__.age + " voted " + this.__data__.total_group_votes + " times. This age represents " + this.__data__.votes_percentage + "%  of the total votes of '" + this.__data__.group + "' group.");
}

var myMouseOutFunction = function() {
  var circle = d3.select(this);
  // display none removes element totally, whereas visibilty in last example just hid it
  d3.select(".infobox").style("display", "none");
}

var ageWidth = 280,
    ageHeight = 350,
    agePadding = 1.5, // separation between same-color nodes
    ageClusterPadding = 6, // separation between different-color nodes
    ageMaxRadius = 50;


// what about creating a structure like this but jsonic style in order to do not perform any
// logic on the viualization side
var nodes_info = <%= raw @nodes_for_bubbles %>
var counter = 0

var n = nodes_info.length,  // total number of nodes
    m = 5;                        // number of distinct clusters for us age groups

var color = d3.scale.category10()
    .domain(d3.range(m));

// The largest node for each cluster.
var clusters = new Array(m);

var nodes = d3.range(n).map(function() {
  var i = nodes_info[counter].group_num;
  var age = nodes_info[counter].age;
  var percentage = nodes_info[counter].total_positive_votes / nodes_info[counter].total_group_votes
  var r = percentage * (ageMaxRadius + 1);
  var d = {
        age: nodes_info[counter].age,
        group: nodes_info[counter].group,
        total_group_votes: nodes_info[counter].total_group_votes,
        votes_percentage: Math.floor(percentage * 100),
        cluster: i,
        radius: r,
        x: Math.cos(i / m * 2 * Math.PI) * 200 + ageWidth / 2 + Math.random(),
        y: Math.sin(i / m * 2 * Math.PI) * 200 + ageHeight / 2 + Math.random()
      };

  counter += 1
  if (!clusters[i] || (r > clusters[i].radius)) clusters[i] = d;
  return d
});

var force = d3.layout.force()
    .nodes(nodes)
    .size([ageWidth, ageHeight])
    .gravity(.02)
    .charge(0)
    .on("tick", ageTick)
    .start();

var svg = d3.select(".agedisplay").append("svg")
    .attr("width", ageWidth)
    .attr("height", ageHeight);

var node = svg.selectAll("circle")
    .data(nodes)
    .enter().append("circle")
    .style("fill", function(d) { return color(d.cluster); })
    .on("mouseover", myMouseOverFunction)
    .on("mouseout", myMouseOutFunction)
    .call(force.drag);

node.transition()
    .duration(750)
    .delay(function(d, i) { return i * 5; })
    .attrTween("r", function(d) {
      var i = d3.interpolate(0, d.radius);
      return function(t) { return d.radius = i(t); };
    });

function ageTick(e) {
  node
      .each(cluster(10 * e.alpha * e.alpha))
      .each(collide(.5))
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
}

// Move d to be adjacent to the cluster node.
function cluster(alpha) {
  return function(d) {
    var cluster = clusters[d.cluster];
    if (cluster === d) return;
    var x = d.x - cluster.x,
        y = d.y - cluster.y,
        l = Math.sqrt(x * x + y * y),
        r = d.radius + cluster.radius;
    if (l != r) {
      l = (l - r) / l * alpha;
      d.x -= x *= l;
      d.y -= y *= l;
      cluster.x += x;
      cluster.y += y;
    }
  };
}

// Resolves collisions between d and all other circles.
function collide(alpha) {
  var quadtree = d3.geom.quadtree(nodes);
  return function(d) {
    var r = d.radius + ageMaxRadius + Math.max(agePadding, ageClusterPadding),
        nx1 = d.x - r,
        nx2 = d.x + r,
        ny1 = d.y - r,
        ny2 = d.y + r;
    quadtree.visit(function(quad, x1, y1, x2, y2) {
      if (quad.point && (quad.point !== d)) {
        var x = d.x - quad.point.x,
            y = d.y - quad.point.y,
            l = Math.sqrt(x * x + y * y),
            r = d.radius + quad.point.radius + (d.cluster === quad.point.cluster ? agePadding : ageClusterPadding);
        if (l < r) {
          l = (l - r) / l * alpha;
          d.x -= x *= l;
          d.y -= y *= l;
          quad.point.x += x;
          quad.point.y += y;
        }
      }
      return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
    });
  };
}
</script>